#多线程
>因为c++要求程序员自己管理对象的生命期，所以在多线程环境下显得尤为困难。如何线程安全的对象生命期管理，是c++多线程的主要问题。

##1. 线程安全的对象构造
唯一的要求就是在构造期间不泄露this指针
    
* 不要在构造函数中注册任何回调。也就是在构造函数里面，不要把this指针传给其它对象，因为在多线程条件下，就有可能发生该构造函数还未执行完毕，其它对象就使用了这个对象。从而导致构造函数和初始化要分开。

* 也不要在构造函数中把this传给跨线程的对象。同理，跨线程对象会在这个对象还未初始化完毕就使用了这个对象。

* 即便在构造函数的最后一行也不行。主要是考虑到继承的情况，执行完当前的构造函数，还会执行其子类的构造函数，也就是说该对象初始化还未完成，同样会发生上述的问题。

##2. 线程安全的对象析构
在多线程条件下，如何在对象的销毁时候避免竞争状态是个难题。
* 之前使用mutex的思想放在析构函数中就不行了。为什么呢？因为析构函数会将mutex对象析构掉。比如有两个线程A和B，A线程在该对象的执行析构，B线程在使用该对象的普通函数。当A线程进入到析构函数中的时候，B线程在等待普通函数中的互斥锁，然后A线程执行完析构后，互斥锁也被析构了，B线程就有可能无限的等待下去。

##3.如何判断一个指针是不是合法指针?
现在有两个指针p1, p2都指向同一个对象Object，在多线程条件下，如何知道指针是否为合法指针非常重要。因为假设线程A通过p1将对象析构掉了，p2就成了空悬指针，再使用p2指针就发生内存错误。
* 方法一，引入一层间接对象，让p1和p2指向这个对象，并使其永久有效。间接对象持有一个指向Object的指针，间接对象通过一些标志或值来判断Object对象是否存在。然而这样做还是有问题，因为同样存在竞争情况，当线程A通过p1析构Object对象时，线程B的p2指向的间接对象的值还是表明Object对象存在时，正准备调用Object时，Object对象已经被线程A析构了。而且间接对象什么时候释放是个问题。

* 方法二，引用计数的方法。其实这个方法就是方法一的进化版本。首先需要将p1和p2编程对象sp1和sp2。间接对象有个指针指向Object和计数器。当sp1析构，间接对象的引用计数就减1，当引用计数减为0时就可以销毁这个间接对象和Object对象了。



 