#线程同步精要

线程同步的四项基本原则:
* 首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果需要暴露先考虑immutable对象;实在不行才暴露可修改的对象，并用同步措施充分保护它
* 其次是使用高级的并发编程构件，如TaskQueue\Producer-Consumer Queue\CountDownLatch等等
* 最后不得已必须使用底层同步原语时，只用非递归的互斥器和条件变量，慎用读写锁、不要使用信号量。因为从正确性上来看，很容易在持有read lock的时候修改了共享收据（调用会修改状态的函数）；从性能上看，读写锁不见得比普通的mutex更高效。信号量不是必备的同步原语，条件变量配合互斥器可以完全替代其功能而且更不容易出错。
* 除了使用atomic整数之外，不自己编写lock-free代码，也不要使用内核级同步原语，不凭空猜测哪种做法性能会更好


##互斥器(mutex)
* 用RAII手法封装mutex的创建、销毁、加锁、解锁
* 只用非递归的mutex。递归的mutex和非递归的mutex的唯一区别在于同一个线程中可以重复对递归的mutex加锁，但是不能重复对非递归的mutex加锁。
* 不手动调用lock()和unlock()函数，交给Gurad对象的构造和析构函数负责
* 每次构造Guard对象的时候，思考一路上已经持有的锁，防止因加锁顺序不同而导致死锁
* 不使用跨进程的mutex，进程间通信只使用TCP sockets
* 必要时考虑用PTHREAD_MUTEX_ERRORCHECK来排错

##条件变量
* 必须与mutex一起使用，该布尔表达式的读写受到mutex的保护
* 在mutex已上锁的时候才能调用wait()
* 把判断布尔条件和wait()放到while循环中，考虑到存在虚假唤醒(spurious weakup)的情况