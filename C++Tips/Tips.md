#C++中的语法细节

##关于`static`
###面向过程中的static
1. 静态全局变量
在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。我们先举一个静态全局变量的例子，如下： //Example 1#include <iostream.h>void fn();static int n; //定义静态全局变量void main(){ n=20; cout<<n<<endl; fn();}

void fn(){ n++; cout<<n<<endl;}静态全局变量有以下特点： • 该变量在全局数据区分配内存； • 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）； • 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；

静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。对于一个完整的程序，在内存中的分布情况如下图： 代码区全局数据区堆区栈区一 般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局 部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。细心的读者可能会发现，Example 1中的代码中将 “static int n; //定义静态全局变量”改为“int n; //定义全局变量”。程序照样正常运行。的确，定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量还有以下好处： • 静态全局变量不能被其它文件所用； • 其它文件中可以定义相同名字的变量，不会发生冲突；

您可以将上述示例代码改为如下：//Example 2//File1#include <iostream.h>void fn();static int n; //定义静态全局变量void main(){ n=20; cout<<n<<endl; fn();}

//File2#include <iostream.h>extern int n;void fn(){ n++; cout<<n<<endl;}编译并运行Example 2，您就会发现上述代码可以分别通过编译，但运行时出现错误。试着将 “static int n; //定义静态全局变量”改为 “int n; //定义全局变量”再次编译运行程序，细心体会“全局变量”和"静态全局变量"的区别。
