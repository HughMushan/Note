#进程与线程的区别与联系

> ![](/assets/20150603133335514.png)


1. 调度：　线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程切换，在不同进程中进行线程的切换会引起进程的切换

2. 拥有资源：　进程是拥有资源的基本单位，线程不拥有资源（有一点必不可少的资源），但线程可以共享其隶属进程的系统资源

3. 并发性：进程可以并发，同一进程内的多个线程也可以并发执行，从而使操作系统具有更好的并发性，大大提高了系统吞吐量

4. 系统开销：创建和撤销进程时，系统都要为之分配或者回收资源，如内存空间、I/O设备等，因此操作系统所付出的开销远大于创建或撤销线程的开销。类似地，在进程切换时，涉及当前执行进程CPU环境的保存以及新调度的进程CPU环境的设置；而线程切换时只需要保存和设置少量寄存器内容，因此开销小。另外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信也比较容易实现，甚至无需操作系统干涉。

5. 地址空间和其它资源：进程的地址空间之间相互独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其它进程是不可见的

6. 通信方面：进程间通信需要借助操作系统，线程间可以直接读写进程数据段来通信

#[Linux进程通信](https://github.com/clpsz/linux-ipcs)

####1. 管道(pipe)

管道是linux系统中最常用的进程间通信方式，我们平常在命令行中使用如下命令：
```shell
cat /tmp/xxx.txt | grep abc
```
就是使用了管道在cat进程和grep进程间传递数据

pipe的限制有两个：

* 只能用于父子进程等有关联的进程之间来通信
* pipe是单工的，如果要相互通信，需要开两个管道


####2. 有名管道(named pipe)

有名管道，也是FIFO(First In First Out)，弥补了管道只能用于有共同祖先的进程间通信的不足，相对于pipe，fifo主要有以下几个优点：

* 可以用于任意进程之间通信
* 可以有多个读/写进程同时对管道进行操作
* 可以像变通文件一样管理管道的权限
* 可以使用标准文件读写方式来操作管道(打开，读/写，关闭)

####3. 消息队列(XSI_MSGQ)
message queue是三种XSI IPC方式之一，另外两种分别是semaphore和shared memory


系统V消息队列API共有四个，使用时需要包括几个头文件：

```c++
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
```

##### 1) `int msgget(key_t key, int msgflg)`

参数key是一个键值，由ftok获得；msgflg参数是一些标志位。该调用返回与健值key相对应的消息队列描述字。
在以下两种情况下，该调用将创建一个新的消息队列：
如果没有消息队列与健值key相对应，并且msgflg中包含了IPC_CREAT标志位；
key参数为IPC_PRIVATE；
参数msgflg可以为以下：IPC_CREAT、IPC_EXCL、IPC_NOWAIT或三者的或结果：

当只有IPC_CREAT选项打开时,若不存在则创建信号量集返回该ID，若存在，则都返回该信号量集的ID，
当只有IPC_EXCL选项打开时，不管有没有该信号量集，shmget()都返回-1
所以当IPC_CREAT | IPC_EXCL时, 如果没有该信号量，则创建，并返回ID。若已有该信号量集，则返回-1；


调用返回：成功返回消息队列描述字，否则返回-1。

注：参数key设置成常数IPC_PRIVATE并不意味着其他进程不能访问该消息队列，只意味着即将创建新的消息队列。


##### 2) `int msgrcv(int msqid, struct msgbuf *msgp, int msgsz,long msgtyp, int msgflg);`

该系统调用从msgid代表的消息队列中读取一个消息，并把消息存储在msgp指向的msgbuf结构中。
msqid为消息队列描述字；消息返回后存储在msgp指向的地址，

msgsz指定msgbuf的mtext成员的长度（即消息内容的长度），

msgtyp为请求读取的消息类型,取值为：0,正整数，负整数

```
0，表示读取队列中的第一条消息
>0, 表示队列中类型为msgtyp的第一条消息被读取；如果msgflg设置成MSG_EXCEPT，则表示队列中除了类型是msgtyp的第一条消息将被读取。
<0, 表示小于或等于msgtyp绝对值的最小的消息类型的第一条消息将被读取。
```

举个例子：假设消息队列中依次有类型为3的消息2个，类型为4的消息2个，类型为1的消息2个。如果msgtyp=0，则读取类型为3的第一条消息；如果msgtyp=4，则读取类型为4的第一条消息（如果msgflg设置成MSG_EXCEPT，则读取类型为3的第一条消息）；如果msgtyp=-3,则读取类型为1的第一条消息。

读消息标志msgflg可以为以下几个常值的或：
IPC_NOWAIT 如果没有满足条件的消息，调用立即返回，此时，errno=ENOMSG
IPC_EXCEPT 与msgtyp>0配合使用，返回队列中第一个类型不为msgtyp的消息
IPC_NOERROR 如果队列中满足条件的消息内容大于所请求的msgsz字节，则把该消息截断，截断部分将丢失。

msgrcv()解除阻塞的条件有三个：
消息队列中有了满足条件的消息；
msqid代表的消息队列被删除；
调用msgrcv（）的进程被信号中断；

调用返回：成功返回读出消息的实际字节数，否则返回-1。

##### 3）`int msgsnd(int msqid, struct msgbuf *msgp, int msgsz, intmsgflg);`

向msgid代表的消息队列发送一个消息，即将发送的消息存储在msgp指向的msgbuf结构中，消息的大小由msgze指定。
对发送消息来说，有意义的msgflg标志为IPC_NOWAIT，指明在消息队列没有足够空间容纳要发送的消息时，msgsnd是否等待。造成msgsnd()等待的条件有两种：
当前消息的大小与当前消息队列中的字节数之和超过了消息队列的总容量；
当前消息队列的消息数（单位"个"）不小于消息队列的总容量（单位"字节数"），此时，虽然消息队列中的消息数目很多，但基本上都只有一个字节。
msgsnd()解除阻塞的条件有三个：
不满足上述两个条件，即消息队列中有容纳该消息的空间；
msqid代表的消息队列被删除；
调用msgsnd（）的进程被信号中断；
调用返回：成功返回0，否则返回-1。

##### 4）`int msgctl(int msqid, int cmd, struct msqid_ds *buf);`
该系统调用对由msqid标识的消息队列执行cmd操作，共有三种cmd操作：IPC_STAT、IPC_SET 、IPC_RMID。

IPC_STAT：该命令用来获取消息队列信息，返回的信息存贮在buf指向的msqid结构中；
IPC_SET：该命令用来设置消息队列的属性，要设置的属性存储在buf指向的msqid结构中；可设置属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes，同时，也影响msg_ctime成员。
IPC_RMID：删除msqid标识的消息队列；

调用返回：成功返回0，否则返回-1。

####4. 共享内存(XSI_SHM)
* 两个或者多个进程共享一块由系统内核维护的内存区域
* 无需复制信息，最快的一种IPC机制，所以适合大文件的传输
* 需要考虑同步访问的问题





